/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "@creditkarma/thrift-server-core";
import * as PingReq from "./PingReq";
import * as PingResp from "./PingResp";
import * as QueueMaterialReq from "./QueueMaterialReq";
import * as QueueMaterialResp from "./QueueMaterialResp";
import * as EmptyRequest from "./EmptyRequest";
import * as TosStsTokenResp from "./TosStsTokenResp";
import * as FolderListReq from "./FolderListReq";
import * as FolderListResp from "./FolderListResp";
import * as FolderDetailReq from "./FolderDetailReq";
import * as FolderDetailResp from "./FolderDetailResp";
import * as FolderCreateReq from "./FolderCreateReq";
import * as FolderCreateResp from "./FolderCreateResp";
import * as FolderUpdateReq from "./FolderUpdateReq";
import * as FolderUpdateResp from "./FolderUpdateResp";
import * as FolderDeleteReq from "./FolderDeleteReq";
import * as FolderDeleteResp from "./FolderDeleteResp";
import * as MaterialListReq from "./MaterialListReq";
import * as MaterialListResp from "./MaterialListResp";
import * as MaterialDetailReq from "./MaterialDetailReq";
import * as MaterialDetailResp from "./MaterialDetailResp";
import * as MaterialCreateReq from "./MaterialCreateReq";
import * as MaterialCreateResp from "./MaterialCreateResp";
import * as MaterialUpdateReq from "./MaterialUpdateReq";
import * as MaterialUpdateResp from "./MaterialUpdateResp";
import * as MaterialDeleteReq from "./MaterialDeleteReq";
import * as MaterialDeleteResp from "./MaterialDeleteResp";
import * as ProductListReq from "./ProductListReq";
import * as ProductListResp from "./ProductListResp";
import * as ProductDetailReq from "./ProductDetailReq";
import * as ProductDetailResp from "./ProductDetailResp";
import * as ProductCreateReq from "./ProductCreateReq";
import * as ProductCreateResp from "./ProductCreateResp";
import * as ProductUpdateReq from "./ProductUpdateReq";
import * as ProductUpdateResp from "./ProductUpdateResp";
import * as ProductDeleteReq from "./ProductDeleteReq";
import * as ProductDeleteResp from "./ProductDeleteResp";
import * as UserRegisterReq from "./UserRegisterReq";
import * as UserRegisterResp from "./UserRegisterResp";
import * as UserLoginReq from "./UserLoginReq";
import * as UserLoginResp from "./UserLoginResp";
import * as UserInfoResp from "./UserInfoResp";
import * as UserUpdateReq from "./UserUpdateReq";
import * as UserUpdateResp from "./UserUpdateResp";
export const serviceName: string = "HttpWebService";
export const annotations: thrift.IThriftAnnotations = {};
export const methodAnnotations: thrift.IMethodAnnotations = {
    Ping: {
        annotations: {
            'api.post': "/api/ping"
        },
        fieldAnnotations: {}
    },
    QueueMaterial: {
        annotations: {
            'api.post': "/api/material/queue"
        },
        fieldAnnotations: {}
    },
    GetTosStsToken: {
        annotations: {
            'api.get': "/api/account/tos-sts-token"
        },
        fieldAnnotations: {}
    },
    GetFolderList: {
        annotations: {
            'api.get': "/api/folders"
        },
        fieldAnnotations: {}
    },
    GetFolderDetail: {
        annotations: {
            'api.get': "/api/folders/{folderId}"
        },
        fieldAnnotations: {}
    },
    CreateFolder: {
        annotations: {
            'api.post': "/api/folders"
        },
        fieldAnnotations: {}
    },
    UpdateFolder: {
        annotations: {
            'api.put': "/api/folders/{folderId}"
        },
        fieldAnnotations: {}
    },
    DeleteFolder: {
        annotations: {
            'api.delete': "/api/folders/{folderId}"
        },
        fieldAnnotations: {}
    },
    GetMaterialList: {
        annotations: {
            'api.get': "/api/materials"
        },
        fieldAnnotations: {}
    },
    GetMaterialDetail: {
        annotations: {
            'api.get': "/api/materials/{materialId}"
        },
        fieldAnnotations: {}
    },
    CreateMaterial: {
        annotations: {
            'api.post': "/api/materials"
        },
        fieldAnnotations: {}
    },
    UpdateMaterial: {
        annotations: {
            'api.put': "/api/materials/{materialId}"
        },
        fieldAnnotations: {}
    },
    DeleteMaterial: {
        annotations: {
            'api.delete': "/api/materials/{materialId}"
        },
        fieldAnnotations: {}
    },
    GetProductList: {
        annotations: {
            'api.get': "/api/products"
        },
        fieldAnnotations: {}
    },
    GetProductDetail: {
        annotations: {
            'api.get': "/api/products/{productId}"
        },
        fieldAnnotations: {}
    },
    CreateProduct: {
        annotations: {
            'api.post': "/api/products"
        },
        fieldAnnotations: {}
    },
    UpdateProduct: {
        annotations: {
            'api.put': "/api/products/{productId}"
        },
        fieldAnnotations: {}
    },
    DeleteProduct: {
        annotations: {
            'api.delete': "/api/products/{productId}"
        },
        fieldAnnotations: {}
    },
    RegisterUser: {
        annotations: {
            'api.post': "/api/user/register"
        },
        fieldAnnotations: {}
    },
    LoginUser: {
        annotations: {
            'api.post': "/api/user/login"
        },
        fieldAnnotations: {}
    },
    GetUserInfo: {
        annotations: {
            'api.get': "/api/user/info"
        },
        fieldAnnotations: {}
    },
    UpdateUser: {
        annotations: {
            'api.put': "/api/user/update"
        },
        fieldAnnotations: {}
    }
};
export const methodNames: Array<string> = ["Ping", "QueueMaterial", "GetTosStsToken", "GetFolderList", "GetFolderDetail", "CreateFolder", "UpdateFolder", "DeleteFolder", "GetMaterialList", "GetMaterialDetail", "CreateMaterial", "UpdateMaterial", "DeleteMaterial", "GetProductList", "GetProductDetail", "CreateProduct", "UpdateProduct", "DeleteProduct", "RegisterUser", "LoginUser", "GetUserInfo", "UpdateUser"];
export const methodParameters: {
    [methodName: string]: number;
} = {
    Ping: 2,
    QueueMaterial: 2,
    GetTosStsToken: 2,
    GetFolderList: 2,
    GetFolderDetail: 2,
    CreateFolder: 2,
    UpdateFolder: 2,
    DeleteFolder: 2,
    GetMaterialList: 2,
    GetMaterialDetail: 2,
    CreateMaterial: 2,
    UpdateMaterial: 2,
    DeleteMaterial: 2,
    GetProductList: 2,
    GetProductDetail: 2,
    CreateProduct: 2,
    UpdateProduct: 2,
    DeleteProduct: 2,
    RegisterUser: 2,
    LoginUser: 2,
    GetUserInfo: 2,
    UpdateUser: 2
};
export interface IPing__Args {
    req: PingReq.IPingReq;
}
export interface IPing__ArgsArgs {
    req: PingReq.IPingReqArgs;
}
export const Ping__ArgsCodec: thrift.IStructCodec<IPing__ArgsArgs, IPing__Args> = {
    encode(args: IPing__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("Ping__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            PingReq.PingReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IPing__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_1: PingReq.IPingReq = PingReq.PingReqCodec.decode(input);
                        _args.req = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read Ping__Args from input");
        }
    }
};
export class Ping__Args extends thrift.StructLike implements IPing__Args {
    public req: PingReq.IPingReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IPing__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_2: PingReq.IPingReq = new PingReq.PingReq(args.req);
            this.req = value_2;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): Ping__Args {
        return new Ping__Args(Ping__ArgsCodec.decode(input));
    }
    public static write(args: IPing__ArgsArgs, output: thrift.TProtocol): void {
        return Ping__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return Ping__ArgsCodec.encode(this, output);
    }
}
export interface IQueueMaterial__Args {
    req: QueueMaterialReq.IQueueMaterialReq;
}
export interface IQueueMaterial__ArgsArgs {
    req: QueueMaterialReq.IQueueMaterialReqArgs;
}
export const QueueMaterial__ArgsCodec: thrift.IStructCodec<IQueueMaterial__ArgsArgs, IQueueMaterial__Args> = {
    encode(args: IQueueMaterial__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("QueueMaterial__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            QueueMaterialReq.QueueMaterialReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IQueueMaterial__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_3: QueueMaterialReq.IQueueMaterialReq = QueueMaterialReq.QueueMaterialReqCodec.decode(input);
                        _args.req = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read QueueMaterial__Args from input");
        }
    }
};
export class QueueMaterial__Args extends thrift.StructLike implements IQueueMaterial__Args {
    public req: QueueMaterialReq.IQueueMaterialReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IQueueMaterial__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_4: QueueMaterialReq.IQueueMaterialReq = new QueueMaterialReq.QueueMaterialReq(args.req);
            this.req = value_4;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): QueueMaterial__Args {
        return new QueueMaterial__Args(QueueMaterial__ArgsCodec.decode(input));
    }
    public static write(args: IQueueMaterial__ArgsArgs, output: thrift.TProtocol): void {
        return QueueMaterial__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return QueueMaterial__ArgsCodec.encode(this, output);
    }
}
export interface IGetTosStsToken__Args {
    req: EmptyRequest.IEmptyRequest;
}
export interface IGetTosStsToken__ArgsArgs {
    req: EmptyRequest.IEmptyRequestArgs;
}
export const GetTosStsToken__ArgsCodec: thrift.IStructCodec<IGetTosStsToken__ArgsArgs, IGetTosStsToken__Args> = {
    encode(args: IGetTosStsToken__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("GetTosStsToken__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, -1);
            EmptyRequest.EmptyRequestCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetTosStsToken__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_5: EmptyRequest.IEmptyRequest = EmptyRequest.EmptyRequestCodec.decode(input);
                        _args.req = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetTosStsToken__Args from input");
        }
    }
};
export class GetTosStsToken__Args extends thrift.StructLike implements IGetTosStsToken__Args {
    public req: EmptyRequest.IEmptyRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetTosStsToken__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_6: EmptyRequest.IEmptyRequest = new EmptyRequest.EmptyRequest(args.req);
            this.req = value_6;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetTosStsToken__Args {
        return new GetTosStsToken__Args(GetTosStsToken__ArgsCodec.decode(input));
    }
    public static write(args: IGetTosStsToken__ArgsArgs, output: thrift.TProtocol): void {
        return GetTosStsToken__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetTosStsToken__ArgsCodec.encode(this, output);
    }
}
export interface IGetFolderList__Args {
    req: FolderListReq.IFolderListReq;
}
export interface IGetFolderList__ArgsArgs {
    req: FolderListReq.IFolderListReqArgs;
}
export const GetFolderList__ArgsCodec: thrift.IStructCodec<IGetFolderList__ArgsArgs, IGetFolderList__Args> = {
    encode(args: IGetFolderList__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("GetFolderList__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            FolderListReq.FolderListReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetFolderList__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_7: FolderListReq.IFolderListReq = FolderListReq.FolderListReqCodec.decode(input);
                        _args.req = value_7;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetFolderList__Args from input");
        }
    }
};
export class GetFolderList__Args extends thrift.StructLike implements IGetFolderList__Args {
    public req: FolderListReq.IFolderListReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetFolderList__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_8: FolderListReq.IFolderListReq = new FolderListReq.FolderListReq(args.req);
            this.req = value_8;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetFolderList__Args {
        return new GetFolderList__Args(GetFolderList__ArgsCodec.decode(input));
    }
    public static write(args: IGetFolderList__ArgsArgs, output: thrift.TProtocol): void {
        return GetFolderList__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetFolderList__ArgsCodec.encode(this, output);
    }
}
export interface IGetFolderDetail__Args {
    req: FolderDetailReq.IFolderDetailReq;
}
export interface IGetFolderDetail__ArgsArgs {
    req: FolderDetailReq.IFolderDetailReqArgs;
}
export const GetFolderDetail__ArgsCodec: thrift.IStructCodec<IGetFolderDetail__ArgsArgs, IGetFolderDetail__Args> = {
    encode(args: IGetFolderDetail__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("GetFolderDetail__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            FolderDetailReq.FolderDetailReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetFolderDetail__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_9: FolderDetailReq.IFolderDetailReq = FolderDetailReq.FolderDetailReqCodec.decode(input);
                        _args.req = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetFolderDetail__Args from input");
        }
    }
};
export class GetFolderDetail__Args extends thrift.StructLike implements IGetFolderDetail__Args {
    public req: FolderDetailReq.IFolderDetailReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetFolderDetail__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_10: FolderDetailReq.IFolderDetailReq = new FolderDetailReq.FolderDetailReq(args.req);
            this.req = value_10;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetFolderDetail__Args {
        return new GetFolderDetail__Args(GetFolderDetail__ArgsCodec.decode(input));
    }
    public static write(args: IGetFolderDetail__ArgsArgs, output: thrift.TProtocol): void {
        return GetFolderDetail__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetFolderDetail__ArgsCodec.encode(this, output);
    }
}
export interface ICreateFolder__Args {
    req: FolderCreateReq.IFolderCreateReq;
}
export interface ICreateFolder__ArgsArgs {
    req: FolderCreateReq.IFolderCreateReqArgs;
}
export const CreateFolder__ArgsCodec: thrift.IStructCodec<ICreateFolder__ArgsArgs, ICreateFolder__Args> = {
    encode(args: ICreateFolder__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("CreateFolder__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            FolderCreateReq.FolderCreateReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICreateFolder__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_11: FolderCreateReq.IFolderCreateReq = FolderCreateReq.FolderCreateReqCodec.decode(input);
                        _args.req = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateFolder__Args from input");
        }
    }
};
export class CreateFolder__Args extends thrift.StructLike implements ICreateFolder__Args {
    public req: FolderCreateReq.IFolderCreateReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ICreateFolder__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_12: FolderCreateReq.IFolderCreateReq = new FolderCreateReq.FolderCreateReq(args.req);
            this.req = value_12;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): CreateFolder__Args {
        return new CreateFolder__Args(CreateFolder__ArgsCodec.decode(input));
    }
    public static write(args: ICreateFolder__ArgsArgs, output: thrift.TProtocol): void {
        return CreateFolder__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CreateFolder__ArgsCodec.encode(this, output);
    }
}
export interface IUpdateFolder__Args {
    req: FolderUpdateReq.IFolderUpdateReq;
}
export interface IUpdateFolder__ArgsArgs {
    req: FolderUpdateReq.IFolderUpdateReqArgs;
}
export const UpdateFolder__ArgsCodec: thrift.IStructCodec<IUpdateFolder__ArgsArgs, IUpdateFolder__Args> = {
    encode(args: IUpdateFolder__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("UpdateFolder__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            FolderUpdateReq.FolderUpdateReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateFolder__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_13: FolderUpdateReq.IFolderUpdateReq = FolderUpdateReq.FolderUpdateReqCodec.decode(input);
                        _args.req = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateFolder__Args from input");
        }
    }
};
export class UpdateFolder__Args extends thrift.StructLike implements IUpdateFolder__Args {
    public req: FolderUpdateReq.IFolderUpdateReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateFolder__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_14: FolderUpdateReq.IFolderUpdateReq = new FolderUpdateReq.FolderUpdateReq(args.req);
            this.req = value_14;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): UpdateFolder__Args {
        return new UpdateFolder__Args(UpdateFolder__ArgsCodec.decode(input));
    }
    public static write(args: IUpdateFolder__ArgsArgs, output: thrift.TProtocol): void {
        return UpdateFolder__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateFolder__ArgsCodec.encode(this, output);
    }
}
export interface IDeleteFolder__Args {
    req: FolderDeleteReq.IFolderDeleteReq;
}
export interface IDeleteFolder__ArgsArgs {
    req: FolderDeleteReq.IFolderDeleteReqArgs;
}
export const DeleteFolder__ArgsCodec: thrift.IStructCodec<IDeleteFolder__ArgsArgs, IDeleteFolder__Args> = {
    encode(args: IDeleteFolder__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("DeleteFolder__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            FolderDeleteReq.FolderDeleteReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDeleteFolder__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_15: FolderDeleteReq.IFolderDeleteReq = FolderDeleteReq.FolderDeleteReqCodec.decode(input);
                        _args.req = value_15;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteFolder__Args from input");
        }
    }
};
export class DeleteFolder__Args extends thrift.StructLike implements IDeleteFolder__Args {
    public req: FolderDeleteReq.IFolderDeleteReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDeleteFolder__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_16: FolderDeleteReq.IFolderDeleteReq = new FolderDeleteReq.FolderDeleteReq(args.req);
            this.req = value_16;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): DeleteFolder__Args {
        return new DeleteFolder__Args(DeleteFolder__ArgsCodec.decode(input));
    }
    public static write(args: IDeleteFolder__ArgsArgs, output: thrift.TProtocol): void {
        return DeleteFolder__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DeleteFolder__ArgsCodec.encode(this, output);
    }
}
export interface IGetMaterialList__Args {
    req: MaterialListReq.IMaterialListReq;
}
export interface IGetMaterialList__ArgsArgs {
    req: MaterialListReq.IMaterialListReqArgs;
}
export const GetMaterialList__ArgsCodec: thrift.IStructCodec<IGetMaterialList__ArgsArgs, IGetMaterialList__Args> = {
    encode(args: IGetMaterialList__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("GetMaterialList__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            MaterialListReq.MaterialListReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetMaterialList__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_17: MaterialListReq.IMaterialListReq = MaterialListReq.MaterialListReqCodec.decode(input);
                        _args.req = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetMaterialList__Args from input");
        }
    }
};
export class GetMaterialList__Args extends thrift.StructLike implements IGetMaterialList__Args {
    public req: MaterialListReq.IMaterialListReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetMaterialList__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_18: MaterialListReq.IMaterialListReq = new MaterialListReq.MaterialListReq(args.req);
            this.req = value_18;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetMaterialList__Args {
        return new GetMaterialList__Args(GetMaterialList__ArgsCodec.decode(input));
    }
    public static write(args: IGetMaterialList__ArgsArgs, output: thrift.TProtocol): void {
        return GetMaterialList__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetMaterialList__ArgsCodec.encode(this, output);
    }
}
export interface IGetMaterialDetail__Args {
    req: MaterialDetailReq.IMaterialDetailReq;
}
export interface IGetMaterialDetail__ArgsArgs {
    req: MaterialDetailReq.IMaterialDetailReqArgs;
}
export const GetMaterialDetail__ArgsCodec: thrift.IStructCodec<IGetMaterialDetail__ArgsArgs, IGetMaterialDetail__Args> = {
    encode(args: IGetMaterialDetail__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("GetMaterialDetail__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            MaterialDetailReq.MaterialDetailReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetMaterialDetail__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_19: MaterialDetailReq.IMaterialDetailReq = MaterialDetailReq.MaterialDetailReqCodec.decode(input);
                        _args.req = value_19;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetMaterialDetail__Args from input");
        }
    }
};
export class GetMaterialDetail__Args extends thrift.StructLike implements IGetMaterialDetail__Args {
    public req: MaterialDetailReq.IMaterialDetailReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetMaterialDetail__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_20: MaterialDetailReq.IMaterialDetailReq = new MaterialDetailReq.MaterialDetailReq(args.req);
            this.req = value_20;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetMaterialDetail__Args {
        return new GetMaterialDetail__Args(GetMaterialDetail__ArgsCodec.decode(input));
    }
    public static write(args: IGetMaterialDetail__ArgsArgs, output: thrift.TProtocol): void {
        return GetMaterialDetail__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetMaterialDetail__ArgsCodec.encode(this, output);
    }
}
export interface ICreateMaterial__Args {
    req: MaterialCreateReq.IMaterialCreateReq;
}
export interface ICreateMaterial__ArgsArgs {
    req: MaterialCreateReq.IMaterialCreateReqArgs;
}
export const CreateMaterial__ArgsCodec: thrift.IStructCodec<ICreateMaterial__ArgsArgs, ICreateMaterial__Args> = {
    encode(args: ICreateMaterial__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("CreateMaterial__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            MaterialCreateReq.MaterialCreateReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICreateMaterial__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_21: MaterialCreateReq.IMaterialCreateReq = MaterialCreateReq.MaterialCreateReqCodec.decode(input);
                        _args.req = value_21;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateMaterial__Args from input");
        }
    }
};
export class CreateMaterial__Args extends thrift.StructLike implements ICreateMaterial__Args {
    public req: MaterialCreateReq.IMaterialCreateReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ICreateMaterial__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_22: MaterialCreateReq.IMaterialCreateReq = new MaterialCreateReq.MaterialCreateReq(args.req);
            this.req = value_22;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): CreateMaterial__Args {
        return new CreateMaterial__Args(CreateMaterial__ArgsCodec.decode(input));
    }
    public static write(args: ICreateMaterial__ArgsArgs, output: thrift.TProtocol): void {
        return CreateMaterial__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CreateMaterial__ArgsCodec.encode(this, output);
    }
}
export interface IUpdateMaterial__Args {
    req: MaterialUpdateReq.IMaterialUpdateReq;
}
export interface IUpdateMaterial__ArgsArgs {
    req: MaterialUpdateReq.IMaterialUpdateReqArgs;
}
export const UpdateMaterial__ArgsCodec: thrift.IStructCodec<IUpdateMaterial__ArgsArgs, IUpdateMaterial__Args> = {
    encode(args: IUpdateMaterial__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("UpdateMaterial__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            MaterialUpdateReq.MaterialUpdateReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateMaterial__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_23: MaterialUpdateReq.IMaterialUpdateReq = MaterialUpdateReq.MaterialUpdateReqCodec.decode(input);
                        _args.req = value_23;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateMaterial__Args from input");
        }
    }
};
export class UpdateMaterial__Args extends thrift.StructLike implements IUpdateMaterial__Args {
    public req: MaterialUpdateReq.IMaterialUpdateReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateMaterial__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_24: MaterialUpdateReq.IMaterialUpdateReq = new MaterialUpdateReq.MaterialUpdateReq(args.req);
            this.req = value_24;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): UpdateMaterial__Args {
        return new UpdateMaterial__Args(UpdateMaterial__ArgsCodec.decode(input));
    }
    public static write(args: IUpdateMaterial__ArgsArgs, output: thrift.TProtocol): void {
        return UpdateMaterial__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateMaterial__ArgsCodec.encode(this, output);
    }
}
export interface IDeleteMaterial__Args {
    req: MaterialDeleteReq.IMaterialDeleteReq;
}
export interface IDeleteMaterial__ArgsArgs {
    req: MaterialDeleteReq.IMaterialDeleteReqArgs;
}
export const DeleteMaterial__ArgsCodec: thrift.IStructCodec<IDeleteMaterial__ArgsArgs, IDeleteMaterial__Args> = {
    encode(args: IDeleteMaterial__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("DeleteMaterial__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            MaterialDeleteReq.MaterialDeleteReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDeleteMaterial__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_25: MaterialDeleteReq.IMaterialDeleteReq = MaterialDeleteReq.MaterialDeleteReqCodec.decode(input);
                        _args.req = value_25;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteMaterial__Args from input");
        }
    }
};
export class DeleteMaterial__Args extends thrift.StructLike implements IDeleteMaterial__Args {
    public req: MaterialDeleteReq.IMaterialDeleteReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDeleteMaterial__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_26: MaterialDeleteReq.IMaterialDeleteReq = new MaterialDeleteReq.MaterialDeleteReq(args.req);
            this.req = value_26;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): DeleteMaterial__Args {
        return new DeleteMaterial__Args(DeleteMaterial__ArgsCodec.decode(input));
    }
    public static write(args: IDeleteMaterial__ArgsArgs, output: thrift.TProtocol): void {
        return DeleteMaterial__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DeleteMaterial__ArgsCodec.encode(this, output);
    }
}
export interface IGetProductList__Args {
    req: ProductListReq.IProductListReq;
}
export interface IGetProductList__ArgsArgs {
    req: ProductListReq.IProductListReqArgs;
}
export const GetProductList__ArgsCodec: thrift.IStructCodec<IGetProductList__ArgsArgs, IGetProductList__Args> = {
    encode(args: IGetProductList__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("GetProductList__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            ProductListReq.ProductListReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetProductList__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_27: ProductListReq.IProductListReq = ProductListReq.ProductListReqCodec.decode(input);
                        _args.req = value_27;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetProductList__Args from input");
        }
    }
};
export class GetProductList__Args extends thrift.StructLike implements IGetProductList__Args {
    public req: ProductListReq.IProductListReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetProductList__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_28: ProductListReq.IProductListReq = new ProductListReq.ProductListReq(args.req);
            this.req = value_28;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetProductList__Args {
        return new GetProductList__Args(GetProductList__ArgsCodec.decode(input));
    }
    public static write(args: IGetProductList__ArgsArgs, output: thrift.TProtocol): void {
        return GetProductList__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetProductList__ArgsCodec.encode(this, output);
    }
}
export interface IGetProductDetail__Args {
    req: ProductDetailReq.IProductDetailReq;
}
export interface IGetProductDetail__ArgsArgs {
    req: ProductDetailReq.IProductDetailReqArgs;
}
export const GetProductDetail__ArgsCodec: thrift.IStructCodec<IGetProductDetail__ArgsArgs, IGetProductDetail__Args> = {
    encode(args: IGetProductDetail__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("GetProductDetail__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            ProductDetailReq.ProductDetailReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetProductDetail__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_29: ProductDetailReq.IProductDetailReq = ProductDetailReq.ProductDetailReqCodec.decode(input);
                        _args.req = value_29;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetProductDetail__Args from input");
        }
    }
};
export class GetProductDetail__Args extends thrift.StructLike implements IGetProductDetail__Args {
    public req: ProductDetailReq.IProductDetailReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetProductDetail__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_30: ProductDetailReq.IProductDetailReq = new ProductDetailReq.ProductDetailReq(args.req);
            this.req = value_30;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetProductDetail__Args {
        return new GetProductDetail__Args(GetProductDetail__ArgsCodec.decode(input));
    }
    public static write(args: IGetProductDetail__ArgsArgs, output: thrift.TProtocol): void {
        return GetProductDetail__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetProductDetail__ArgsCodec.encode(this, output);
    }
}
export interface ICreateProduct__Args {
    req: ProductCreateReq.IProductCreateReq;
}
export interface ICreateProduct__ArgsArgs {
    req: ProductCreateReq.IProductCreateReqArgs;
}
export const CreateProduct__ArgsCodec: thrift.IStructCodec<ICreateProduct__ArgsArgs, ICreateProduct__Args> = {
    encode(args: ICreateProduct__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("CreateProduct__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            ProductCreateReq.ProductCreateReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICreateProduct__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_31: ProductCreateReq.IProductCreateReq = ProductCreateReq.ProductCreateReqCodec.decode(input);
                        _args.req = value_31;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateProduct__Args from input");
        }
    }
};
export class CreateProduct__Args extends thrift.StructLike implements ICreateProduct__Args {
    public req: ProductCreateReq.IProductCreateReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ICreateProduct__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_32: ProductCreateReq.IProductCreateReq = new ProductCreateReq.ProductCreateReq(args.req);
            this.req = value_32;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): CreateProduct__Args {
        return new CreateProduct__Args(CreateProduct__ArgsCodec.decode(input));
    }
    public static write(args: ICreateProduct__ArgsArgs, output: thrift.TProtocol): void {
        return CreateProduct__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CreateProduct__ArgsCodec.encode(this, output);
    }
}
export interface IUpdateProduct__Args {
    req: ProductUpdateReq.IProductUpdateReq;
}
export interface IUpdateProduct__ArgsArgs {
    req: ProductUpdateReq.IProductUpdateReqArgs;
}
export const UpdateProduct__ArgsCodec: thrift.IStructCodec<IUpdateProduct__ArgsArgs, IUpdateProduct__Args> = {
    encode(args: IUpdateProduct__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("UpdateProduct__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            ProductUpdateReq.ProductUpdateReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateProduct__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_33: ProductUpdateReq.IProductUpdateReq = ProductUpdateReq.ProductUpdateReqCodec.decode(input);
                        _args.req = value_33;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateProduct__Args from input");
        }
    }
};
export class UpdateProduct__Args extends thrift.StructLike implements IUpdateProduct__Args {
    public req: ProductUpdateReq.IProductUpdateReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateProduct__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_34: ProductUpdateReq.IProductUpdateReq = new ProductUpdateReq.ProductUpdateReq(args.req);
            this.req = value_34;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): UpdateProduct__Args {
        return new UpdateProduct__Args(UpdateProduct__ArgsCodec.decode(input));
    }
    public static write(args: IUpdateProduct__ArgsArgs, output: thrift.TProtocol): void {
        return UpdateProduct__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateProduct__ArgsCodec.encode(this, output);
    }
}
export interface IDeleteProduct__Args {
    req: ProductDeleteReq.IProductDeleteReq;
}
export interface IDeleteProduct__ArgsArgs {
    req: ProductDeleteReq.IProductDeleteReqArgs;
}
export const DeleteProduct__ArgsCodec: thrift.IStructCodec<IDeleteProduct__ArgsArgs, IDeleteProduct__Args> = {
    encode(args: IDeleteProduct__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("DeleteProduct__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            ProductDeleteReq.ProductDeleteReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDeleteProduct__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_35: ProductDeleteReq.IProductDeleteReq = ProductDeleteReq.ProductDeleteReqCodec.decode(input);
                        _args.req = value_35;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteProduct__Args from input");
        }
    }
};
export class DeleteProduct__Args extends thrift.StructLike implements IDeleteProduct__Args {
    public req: ProductDeleteReq.IProductDeleteReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDeleteProduct__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_36: ProductDeleteReq.IProductDeleteReq = new ProductDeleteReq.ProductDeleteReq(args.req);
            this.req = value_36;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): DeleteProduct__Args {
        return new DeleteProduct__Args(DeleteProduct__ArgsCodec.decode(input));
    }
    public static write(args: IDeleteProduct__ArgsArgs, output: thrift.TProtocol): void {
        return DeleteProduct__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DeleteProduct__ArgsCodec.encode(this, output);
    }
}
export interface IRegisterUser__Args {
    req: UserRegisterReq.IUserRegisterReq;
}
export interface IRegisterUser__ArgsArgs {
    req: UserRegisterReq.IUserRegisterReqArgs;
}
export const RegisterUser__ArgsCodec: thrift.IStructCodec<IRegisterUser__ArgsArgs, IRegisterUser__Args> = {
    encode(args: IRegisterUser__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("RegisterUser__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            UserRegisterReq.UserRegisterReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IRegisterUser__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_37: UserRegisterReq.IUserRegisterReq = UserRegisterReq.UserRegisterReqCodec.decode(input);
                        _args.req = value_37;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RegisterUser__Args from input");
        }
    }
};
export class RegisterUser__Args extends thrift.StructLike implements IRegisterUser__Args {
    public req: UserRegisterReq.IUserRegisterReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IRegisterUser__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_38: UserRegisterReq.IUserRegisterReq = new UserRegisterReq.UserRegisterReq(args.req);
            this.req = value_38;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): RegisterUser__Args {
        return new RegisterUser__Args(RegisterUser__ArgsCodec.decode(input));
    }
    public static write(args: IRegisterUser__ArgsArgs, output: thrift.TProtocol): void {
        return RegisterUser__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return RegisterUser__ArgsCodec.encode(this, output);
    }
}
export interface ILoginUser__Args {
    req: UserLoginReq.IUserLoginReq;
}
export interface ILoginUser__ArgsArgs {
    req: UserLoginReq.IUserLoginReqArgs;
}
export const LoginUser__ArgsCodec: thrift.IStructCodec<ILoginUser__ArgsArgs, ILoginUser__Args> = {
    encode(args: ILoginUser__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("LoginUser__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            UserLoginReq.UserLoginReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ILoginUser__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_39: UserLoginReq.IUserLoginReq = UserLoginReq.UserLoginReqCodec.decode(input);
                        _args.req = value_39;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read LoginUser__Args from input");
        }
    }
};
export class LoginUser__Args extends thrift.StructLike implements ILoginUser__Args {
    public req: UserLoginReq.IUserLoginReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ILoginUser__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_40: UserLoginReq.IUserLoginReq = new UserLoginReq.UserLoginReq(args.req);
            this.req = value_40;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): LoginUser__Args {
        return new LoginUser__Args(LoginUser__ArgsCodec.decode(input));
    }
    public static write(args: ILoginUser__ArgsArgs, output: thrift.TProtocol): void {
        return LoginUser__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return LoginUser__ArgsCodec.encode(this, output);
    }
}
export interface IGetUserInfo__Args {
    req: EmptyRequest.IEmptyRequest;
}
export interface IGetUserInfo__ArgsArgs {
    req: EmptyRequest.IEmptyRequestArgs;
}
export const GetUserInfo__ArgsCodec: thrift.IStructCodec<IGetUserInfo__ArgsArgs, IGetUserInfo__Args> = {
    encode(args: IGetUserInfo__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("GetUserInfo__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            EmptyRequest.EmptyRequestCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetUserInfo__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_41: EmptyRequest.IEmptyRequest = EmptyRequest.EmptyRequestCodec.decode(input);
                        _args.req = value_41;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetUserInfo__Args from input");
        }
    }
};
export class GetUserInfo__Args extends thrift.StructLike implements IGetUserInfo__Args {
    public req: EmptyRequest.IEmptyRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetUserInfo__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_42: EmptyRequest.IEmptyRequest = new EmptyRequest.EmptyRequest(args.req);
            this.req = value_42;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetUserInfo__Args {
        return new GetUserInfo__Args(GetUserInfo__ArgsCodec.decode(input));
    }
    public static write(args: IGetUserInfo__ArgsArgs, output: thrift.TProtocol): void {
        return GetUserInfo__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetUserInfo__ArgsCodec.encode(this, output);
    }
}
export interface IUpdateUser__Args {
    req: UserUpdateReq.IUserUpdateReq;
}
export interface IUpdateUser__ArgsArgs {
    req: UserUpdateReq.IUserUpdateReqArgs;
}
export const UpdateUser__ArgsCodec: thrift.IStructCodec<IUpdateUser__ArgsArgs, IUpdateUser__Args> = {
    encode(args: IUpdateUser__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("UpdateUser__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            UserUpdateReq.UserUpdateReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateUser__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_43: UserUpdateReq.IUserUpdateReq = UserUpdateReq.UserUpdateReqCodec.decode(input);
                        _args.req = value_43;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateUser__Args from input");
        }
    }
};
export class UpdateUser__Args extends thrift.StructLike implements IUpdateUser__Args {
    public req: UserUpdateReq.IUserUpdateReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateUser__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_44: UserUpdateReq.IUserUpdateReq = new UserUpdateReq.UserUpdateReq(args.req);
            this.req = value_44;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): UpdateUser__Args {
        return new UpdateUser__Args(UpdateUser__ArgsCodec.decode(input));
    }
    public static write(args: IUpdateUser__ArgsArgs, output: thrift.TProtocol): void {
        return UpdateUser__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateUser__ArgsCodec.encode(this, output);
    }
}
export interface IPing__Result {
    success?: PingResp.IPingResp;
}
export interface IPing__ResultArgs {
    success?: PingResp.IPingRespArgs;
}
export const Ping__ResultCodec: thrift.IStructCodec<IPing__ResultArgs, IPing__Result> = {
    encode(args: IPing__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("Ping__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            PingResp.PingRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IPing__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_45: PingResp.IPingResp = PingResp.PingRespCodec.decode(input);
                        _args.success = value_45;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class Ping__Result extends thrift.StructLike implements IPing__Result {
    public success?: PingResp.IPingResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IPing__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_46: PingResp.IPingResp = new PingResp.PingResp(args.success);
            this.success = value_46;
        }
    }
    public static read(input: thrift.TProtocol): Ping__Result {
        return new Ping__Result(Ping__ResultCodec.decode(input));
    }
    public static write(args: IPing__ResultArgs, output: thrift.TProtocol): void {
        return Ping__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return Ping__ResultCodec.encode(this, output);
    }
}
export interface IQueueMaterial__Result {
    success?: QueueMaterialResp.IQueueMaterialResp;
}
export interface IQueueMaterial__ResultArgs {
    success?: QueueMaterialResp.IQueueMaterialRespArgs;
}
export const QueueMaterial__ResultCodec: thrift.IStructCodec<IQueueMaterial__ResultArgs, IQueueMaterial__Result> = {
    encode(args: IQueueMaterial__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("QueueMaterial__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            QueueMaterialResp.QueueMaterialRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IQueueMaterial__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_47: QueueMaterialResp.IQueueMaterialResp = QueueMaterialResp.QueueMaterialRespCodec.decode(input);
                        _args.success = value_47;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class QueueMaterial__Result extends thrift.StructLike implements IQueueMaterial__Result {
    public success?: QueueMaterialResp.IQueueMaterialResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IQueueMaterial__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_48: QueueMaterialResp.IQueueMaterialResp = new QueueMaterialResp.QueueMaterialResp(args.success);
            this.success = value_48;
        }
    }
    public static read(input: thrift.TProtocol): QueueMaterial__Result {
        return new QueueMaterial__Result(QueueMaterial__ResultCodec.decode(input));
    }
    public static write(args: IQueueMaterial__ResultArgs, output: thrift.TProtocol): void {
        return QueueMaterial__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return QueueMaterial__ResultCodec.encode(this, output);
    }
}
export interface IGetTosStsToken__Result {
    success?: TosStsTokenResp.ITosStsTokenResp;
}
export interface IGetTosStsToken__ResultArgs {
    success?: TosStsTokenResp.ITosStsTokenRespArgs;
}
export const GetTosStsToken__ResultCodec: thrift.IStructCodec<IGetTosStsToken__ResultArgs, IGetTosStsToken__Result> = {
    encode(args: IGetTosStsToken__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetTosStsToken__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            TosStsTokenResp.TosStsTokenRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetTosStsToken__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_49: TosStsTokenResp.ITosStsTokenResp = TosStsTokenResp.TosStsTokenRespCodec.decode(input);
                        _args.success = value_49;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetTosStsToken__Result extends thrift.StructLike implements IGetTosStsToken__Result {
    public success?: TosStsTokenResp.ITosStsTokenResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetTosStsToken__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_50: TosStsTokenResp.ITosStsTokenResp = new TosStsTokenResp.TosStsTokenResp(args.success);
            this.success = value_50;
        }
    }
    public static read(input: thrift.TProtocol): GetTosStsToken__Result {
        return new GetTosStsToken__Result(GetTosStsToken__ResultCodec.decode(input));
    }
    public static write(args: IGetTosStsToken__ResultArgs, output: thrift.TProtocol): void {
        return GetTosStsToken__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetTosStsToken__ResultCodec.encode(this, output);
    }
}
export interface IGetFolderList__Result {
    success?: FolderListResp.IFolderListResp;
}
export interface IGetFolderList__ResultArgs {
    success?: FolderListResp.IFolderListRespArgs;
}
export const GetFolderList__ResultCodec: thrift.IStructCodec<IGetFolderList__ResultArgs, IGetFolderList__Result> = {
    encode(args: IGetFolderList__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetFolderList__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            FolderListResp.FolderListRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetFolderList__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_51: FolderListResp.IFolderListResp = FolderListResp.FolderListRespCodec.decode(input);
                        _args.success = value_51;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetFolderList__Result extends thrift.StructLike implements IGetFolderList__Result {
    public success?: FolderListResp.IFolderListResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetFolderList__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_52: FolderListResp.IFolderListResp = new FolderListResp.FolderListResp(args.success);
            this.success = value_52;
        }
    }
    public static read(input: thrift.TProtocol): GetFolderList__Result {
        return new GetFolderList__Result(GetFolderList__ResultCodec.decode(input));
    }
    public static write(args: IGetFolderList__ResultArgs, output: thrift.TProtocol): void {
        return GetFolderList__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetFolderList__ResultCodec.encode(this, output);
    }
}
export interface IGetFolderDetail__Result {
    success?: FolderDetailResp.IFolderDetailResp;
}
export interface IGetFolderDetail__ResultArgs {
    success?: FolderDetailResp.IFolderDetailRespArgs;
}
export const GetFolderDetail__ResultCodec: thrift.IStructCodec<IGetFolderDetail__ResultArgs, IGetFolderDetail__Result> = {
    encode(args: IGetFolderDetail__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetFolderDetail__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            FolderDetailResp.FolderDetailRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetFolderDetail__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_53: FolderDetailResp.IFolderDetailResp = FolderDetailResp.FolderDetailRespCodec.decode(input);
                        _args.success = value_53;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetFolderDetail__Result extends thrift.StructLike implements IGetFolderDetail__Result {
    public success?: FolderDetailResp.IFolderDetailResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetFolderDetail__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_54: FolderDetailResp.IFolderDetailResp = new FolderDetailResp.FolderDetailResp(args.success);
            this.success = value_54;
        }
    }
    public static read(input: thrift.TProtocol): GetFolderDetail__Result {
        return new GetFolderDetail__Result(GetFolderDetail__ResultCodec.decode(input));
    }
    public static write(args: IGetFolderDetail__ResultArgs, output: thrift.TProtocol): void {
        return GetFolderDetail__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetFolderDetail__ResultCodec.encode(this, output);
    }
}
export interface ICreateFolder__Result {
    success?: FolderCreateResp.IFolderCreateResp;
}
export interface ICreateFolder__ResultArgs {
    success?: FolderCreateResp.IFolderCreateRespArgs;
}
export const CreateFolder__ResultCodec: thrift.IStructCodec<ICreateFolder__ResultArgs, ICreateFolder__Result> = {
    encode(args: ICreateFolder__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("CreateFolder__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            FolderCreateResp.FolderCreateRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICreateFolder__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_55: FolderCreateResp.IFolderCreateResp = FolderCreateResp.FolderCreateRespCodec.decode(input);
                        _args.success = value_55;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class CreateFolder__Result extends thrift.StructLike implements ICreateFolder__Result {
    public success?: FolderCreateResp.IFolderCreateResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ICreateFolder__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_56: FolderCreateResp.IFolderCreateResp = new FolderCreateResp.FolderCreateResp(args.success);
            this.success = value_56;
        }
    }
    public static read(input: thrift.TProtocol): CreateFolder__Result {
        return new CreateFolder__Result(CreateFolder__ResultCodec.decode(input));
    }
    public static write(args: ICreateFolder__ResultArgs, output: thrift.TProtocol): void {
        return CreateFolder__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CreateFolder__ResultCodec.encode(this, output);
    }
}
export interface IUpdateFolder__Result {
    success?: FolderUpdateResp.IFolderUpdateResp;
}
export interface IUpdateFolder__ResultArgs {
    success?: FolderUpdateResp.IFolderUpdateRespArgs;
}
export const UpdateFolder__ResultCodec: thrift.IStructCodec<IUpdateFolder__ResultArgs, IUpdateFolder__Result> = {
    encode(args: IUpdateFolder__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("UpdateFolder__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            FolderUpdateResp.FolderUpdateRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateFolder__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_57: FolderUpdateResp.IFolderUpdateResp = FolderUpdateResp.FolderUpdateRespCodec.decode(input);
                        _args.success = value_57;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class UpdateFolder__Result extends thrift.StructLike implements IUpdateFolder__Result {
    public success?: FolderUpdateResp.IFolderUpdateResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateFolder__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_58: FolderUpdateResp.IFolderUpdateResp = new FolderUpdateResp.FolderUpdateResp(args.success);
            this.success = value_58;
        }
    }
    public static read(input: thrift.TProtocol): UpdateFolder__Result {
        return new UpdateFolder__Result(UpdateFolder__ResultCodec.decode(input));
    }
    public static write(args: IUpdateFolder__ResultArgs, output: thrift.TProtocol): void {
        return UpdateFolder__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateFolder__ResultCodec.encode(this, output);
    }
}
export interface IDeleteFolder__Result {
    success?: FolderDeleteResp.IFolderDeleteResp;
}
export interface IDeleteFolder__ResultArgs {
    success?: FolderDeleteResp.IFolderDeleteRespArgs;
}
export const DeleteFolder__ResultCodec: thrift.IStructCodec<IDeleteFolder__ResultArgs, IDeleteFolder__Result> = {
    encode(args: IDeleteFolder__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("DeleteFolder__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            FolderDeleteResp.FolderDeleteRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDeleteFolder__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_59: FolderDeleteResp.IFolderDeleteResp = FolderDeleteResp.FolderDeleteRespCodec.decode(input);
                        _args.success = value_59;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class DeleteFolder__Result extends thrift.StructLike implements IDeleteFolder__Result {
    public success?: FolderDeleteResp.IFolderDeleteResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDeleteFolder__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_60: FolderDeleteResp.IFolderDeleteResp = new FolderDeleteResp.FolderDeleteResp(args.success);
            this.success = value_60;
        }
    }
    public static read(input: thrift.TProtocol): DeleteFolder__Result {
        return new DeleteFolder__Result(DeleteFolder__ResultCodec.decode(input));
    }
    public static write(args: IDeleteFolder__ResultArgs, output: thrift.TProtocol): void {
        return DeleteFolder__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DeleteFolder__ResultCodec.encode(this, output);
    }
}
export interface IGetMaterialList__Result {
    success?: MaterialListResp.IMaterialListResp;
}
export interface IGetMaterialList__ResultArgs {
    success?: MaterialListResp.IMaterialListRespArgs;
}
export const GetMaterialList__ResultCodec: thrift.IStructCodec<IGetMaterialList__ResultArgs, IGetMaterialList__Result> = {
    encode(args: IGetMaterialList__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetMaterialList__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            MaterialListResp.MaterialListRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetMaterialList__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_61: MaterialListResp.IMaterialListResp = MaterialListResp.MaterialListRespCodec.decode(input);
                        _args.success = value_61;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetMaterialList__Result extends thrift.StructLike implements IGetMaterialList__Result {
    public success?: MaterialListResp.IMaterialListResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetMaterialList__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_62: MaterialListResp.IMaterialListResp = new MaterialListResp.MaterialListResp(args.success);
            this.success = value_62;
        }
    }
    public static read(input: thrift.TProtocol): GetMaterialList__Result {
        return new GetMaterialList__Result(GetMaterialList__ResultCodec.decode(input));
    }
    public static write(args: IGetMaterialList__ResultArgs, output: thrift.TProtocol): void {
        return GetMaterialList__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetMaterialList__ResultCodec.encode(this, output);
    }
}
export interface IGetMaterialDetail__Result {
    success?: MaterialDetailResp.IMaterialDetailResp;
}
export interface IGetMaterialDetail__ResultArgs {
    success?: MaterialDetailResp.IMaterialDetailRespArgs;
}
export const GetMaterialDetail__ResultCodec: thrift.IStructCodec<IGetMaterialDetail__ResultArgs, IGetMaterialDetail__Result> = {
    encode(args: IGetMaterialDetail__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetMaterialDetail__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            MaterialDetailResp.MaterialDetailRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetMaterialDetail__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_63: MaterialDetailResp.IMaterialDetailResp = MaterialDetailResp.MaterialDetailRespCodec.decode(input);
                        _args.success = value_63;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetMaterialDetail__Result extends thrift.StructLike implements IGetMaterialDetail__Result {
    public success?: MaterialDetailResp.IMaterialDetailResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetMaterialDetail__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_64: MaterialDetailResp.IMaterialDetailResp = new MaterialDetailResp.MaterialDetailResp(args.success);
            this.success = value_64;
        }
    }
    public static read(input: thrift.TProtocol): GetMaterialDetail__Result {
        return new GetMaterialDetail__Result(GetMaterialDetail__ResultCodec.decode(input));
    }
    public static write(args: IGetMaterialDetail__ResultArgs, output: thrift.TProtocol): void {
        return GetMaterialDetail__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetMaterialDetail__ResultCodec.encode(this, output);
    }
}
export interface ICreateMaterial__Result {
    success?: MaterialCreateResp.IMaterialCreateResp;
}
export interface ICreateMaterial__ResultArgs {
    success?: MaterialCreateResp.IMaterialCreateRespArgs;
}
export const CreateMaterial__ResultCodec: thrift.IStructCodec<ICreateMaterial__ResultArgs, ICreateMaterial__Result> = {
    encode(args: ICreateMaterial__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("CreateMaterial__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            MaterialCreateResp.MaterialCreateRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICreateMaterial__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_65: MaterialCreateResp.IMaterialCreateResp = MaterialCreateResp.MaterialCreateRespCodec.decode(input);
                        _args.success = value_65;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class CreateMaterial__Result extends thrift.StructLike implements ICreateMaterial__Result {
    public success?: MaterialCreateResp.IMaterialCreateResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ICreateMaterial__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_66: MaterialCreateResp.IMaterialCreateResp = new MaterialCreateResp.MaterialCreateResp(args.success);
            this.success = value_66;
        }
    }
    public static read(input: thrift.TProtocol): CreateMaterial__Result {
        return new CreateMaterial__Result(CreateMaterial__ResultCodec.decode(input));
    }
    public static write(args: ICreateMaterial__ResultArgs, output: thrift.TProtocol): void {
        return CreateMaterial__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CreateMaterial__ResultCodec.encode(this, output);
    }
}
export interface IUpdateMaterial__Result {
    success?: MaterialUpdateResp.IMaterialUpdateResp;
}
export interface IUpdateMaterial__ResultArgs {
    success?: MaterialUpdateResp.IMaterialUpdateRespArgs;
}
export const UpdateMaterial__ResultCodec: thrift.IStructCodec<IUpdateMaterial__ResultArgs, IUpdateMaterial__Result> = {
    encode(args: IUpdateMaterial__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("UpdateMaterial__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            MaterialUpdateResp.MaterialUpdateRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateMaterial__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_67: MaterialUpdateResp.IMaterialUpdateResp = MaterialUpdateResp.MaterialUpdateRespCodec.decode(input);
                        _args.success = value_67;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class UpdateMaterial__Result extends thrift.StructLike implements IUpdateMaterial__Result {
    public success?: MaterialUpdateResp.IMaterialUpdateResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateMaterial__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_68: MaterialUpdateResp.IMaterialUpdateResp = new MaterialUpdateResp.MaterialUpdateResp(args.success);
            this.success = value_68;
        }
    }
    public static read(input: thrift.TProtocol): UpdateMaterial__Result {
        return new UpdateMaterial__Result(UpdateMaterial__ResultCodec.decode(input));
    }
    public static write(args: IUpdateMaterial__ResultArgs, output: thrift.TProtocol): void {
        return UpdateMaterial__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateMaterial__ResultCodec.encode(this, output);
    }
}
export interface IDeleteMaterial__Result {
    success?: MaterialDeleteResp.IMaterialDeleteResp;
}
export interface IDeleteMaterial__ResultArgs {
    success?: MaterialDeleteResp.IMaterialDeleteRespArgs;
}
export const DeleteMaterial__ResultCodec: thrift.IStructCodec<IDeleteMaterial__ResultArgs, IDeleteMaterial__Result> = {
    encode(args: IDeleteMaterial__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("DeleteMaterial__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            MaterialDeleteResp.MaterialDeleteRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDeleteMaterial__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_69: MaterialDeleteResp.IMaterialDeleteResp = MaterialDeleteResp.MaterialDeleteRespCodec.decode(input);
                        _args.success = value_69;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class DeleteMaterial__Result extends thrift.StructLike implements IDeleteMaterial__Result {
    public success?: MaterialDeleteResp.IMaterialDeleteResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDeleteMaterial__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_70: MaterialDeleteResp.IMaterialDeleteResp = new MaterialDeleteResp.MaterialDeleteResp(args.success);
            this.success = value_70;
        }
    }
    public static read(input: thrift.TProtocol): DeleteMaterial__Result {
        return new DeleteMaterial__Result(DeleteMaterial__ResultCodec.decode(input));
    }
    public static write(args: IDeleteMaterial__ResultArgs, output: thrift.TProtocol): void {
        return DeleteMaterial__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DeleteMaterial__ResultCodec.encode(this, output);
    }
}
export interface IGetProductList__Result {
    success?: ProductListResp.IProductListResp;
}
export interface IGetProductList__ResultArgs {
    success?: ProductListResp.IProductListRespArgs;
}
export const GetProductList__ResultCodec: thrift.IStructCodec<IGetProductList__ResultArgs, IGetProductList__Result> = {
    encode(args: IGetProductList__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetProductList__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            ProductListResp.ProductListRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetProductList__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_71: ProductListResp.IProductListResp = ProductListResp.ProductListRespCodec.decode(input);
                        _args.success = value_71;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetProductList__Result extends thrift.StructLike implements IGetProductList__Result {
    public success?: ProductListResp.IProductListResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetProductList__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_72: ProductListResp.IProductListResp = new ProductListResp.ProductListResp(args.success);
            this.success = value_72;
        }
    }
    public static read(input: thrift.TProtocol): GetProductList__Result {
        return new GetProductList__Result(GetProductList__ResultCodec.decode(input));
    }
    public static write(args: IGetProductList__ResultArgs, output: thrift.TProtocol): void {
        return GetProductList__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetProductList__ResultCodec.encode(this, output);
    }
}
export interface IGetProductDetail__Result {
    success?: ProductDetailResp.IProductDetailResp;
}
export interface IGetProductDetail__ResultArgs {
    success?: ProductDetailResp.IProductDetailRespArgs;
}
export const GetProductDetail__ResultCodec: thrift.IStructCodec<IGetProductDetail__ResultArgs, IGetProductDetail__Result> = {
    encode(args: IGetProductDetail__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetProductDetail__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            ProductDetailResp.ProductDetailRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetProductDetail__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_73: ProductDetailResp.IProductDetailResp = ProductDetailResp.ProductDetailRespCodec.decode(input);
                        _args.success = value_73;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetProductDetail__Result extends thrift.StructLike implements IGetProductDetail__Result {
    public success?: ProductDetailResp.IProductDetailResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetProductDetail__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_74: ProductDetailResp.IProductDetailResp = new ProductDetailResp.ProductDetailResp(args.success);
            this.success = value_74;
        }
    }
    public static read(input: thrift.TProtocol): GetProductDetail__Result {
        return new GetProductDetail__Result(GetProductDetail__ResultCodec.decode(input));
    }
    public static write(args: IGetProductDetail__ResultArgs, output: thrift.TProtocol): void {
        return GetProductDetail__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetProductDetail__ResultCodec.encode(this, output);
    }
}
export interface ICreateProduct__Result {
    success?: ProductCreateResp.IProductCreateResp;
}
export interface ICreateProduct__ResultArgs {
    success?: ProductCreateResp.IProductCreateRespArgs;
}
export const CreateProduct__ResultCodec: thrift.IStructCodec<ICreateProduct__ResultArgs, ICreateProduct__Result> = {
    encode(args: ICreateProduct__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("CreateProduct__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            ProductCreateResp.ProductCreateRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICreateProduct__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_75: ProductCreateResp.IProductCreateResp = ProductCreateResp.ProductCreateRespCodec.decode(input);
                        _args.success = value_75;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class CreateProduct__Result extends thrift.StructLike implements ICreateProduct__Result {
    public success?: ProductCreateResp.IProductCreateResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ICreateProduct__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_76: ProductCreateResp.IProductCreateResp = new ProductCreateResp.ProductCreateResp(args.success);
            this.success = value_76;
        }
    }
    public static read(input: thrift.TProtocol): CreateProduct__Result {
        return new CreateProduct__Result(CreateProduct__ResultCodec.decode(input));
    }
    public static write(args: ICreateProduct__ResultArgs, output: thrift.TProtocol): void {
        return CreateProduct__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CreateProduct__ResultCodec.encode(this, output);
    }
}
export interface IUpdateProduct__Result {
    success?: ProductUpdateResp.IProductUpdateResp;
}
export interface IUpdateProduct__ResultArgs {
    success?: ProductUpdateResp.IProductUpdateRespArgs;
}
export const UpdateProduct__ResultCodec: thrift.IStructCodec<IUpdateProduct__ResultArgs, IUpdateProduct__Result> = {
    encode(args: IUpdateProduct__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("UpdateProduct__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            ProductUpdateResp.ProductUpdateRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateProduct__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_77: ProductUpdateResp.IProductUpdateResp = ProductUpdateResp.ProductUpdateRespCodec.decode(input);
                        _args.success = value_77;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class UpdateProduct__Result extends thrift.StructLike implements IUpdateProduct__Result {
    public success?: ProductUpdateResp.IProductUpdateResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateProduct__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_78: ProductUpdateResp.IProductUpdateResp = new ProductUpdateResp.ProductUpdateResp(args.success);
            this.success = value_78;
        }
    }
    public static read(input: thrift.TProtocol): UpdateProduct__Result {
        return new UpdateProduct__Result(UpdateProduct__ResultCodec.decode(input));
    }
    public static write(args: IUpdateProduct__ResultArgs, output: thrift.TProtocol): void {
        return UpdateProduct__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateProduct__ResultCodec.encode(this, output);
    }
}
export interface IDeleteProduct__Result {
    success?: ProductDeleteResp.IProductDeleteResp;
}
export interface IDeleteProduct__ResultArgs {
    success?: ProductDeleteResp.IProductDeleteRespArgs;
}
export const DeleteProduct__ResultCodec: thrift.IStructCodec<IDeleteProduct__ResultArgs, IDeleteProduct__Result> = {
    encode(args: IDeleteProduct__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("DeleteProduct__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            ProductDeleteResp.ProductDeleteRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDeleteProduct__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_79: ProductDeleteResp.IProductDeleteResp = ProductDeleteResp.ProductDeleteRespCodec.decode(input);
                        _args.success = value_79;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class DeleteProduct__Result extends thrift.StructLike implements IDeleteProduct__Result {
    public success?: ProductDeleteResp.IProductDeleteResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDeleteProduct__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_80: ProductDeleteResp.IProductDeleteResp = new ProductDeleteResp.ProductDeleteResp(args.success);
            this.success = value_80;
        }
    }
    public static read(input: thrift.TProtocol): DeleteProduct__Result {
        return new DeleteProduct__Result(DeleteProduct__ResultCodec.decode(input));
    }
    public static write(args: IDeleteProduct__ResultArgs, output: thrift.TProtocol): void {
        return DeleteProduct__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DeleteProduct__ResultCodec.encode(this, output);
    }
}
export interface IRegisterUser__Result {
    success?: UserRegisterResp.IUserRegisterResp;
}
export interface IRegisterUser__ResultArgs {
    success?: UserRegisterResp.IUserRegisterRespArgs;
}
export const RegisterUser__ResultCodec: thrift.IStructCodec<IRegisterUser__ResultArgs, IRegisterUser__Result> = {
    encode(args: IRegisterUser__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("RegisterUser__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            UserRegisterResp.UserRegisterRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IRegisterUser__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_81: UserRegisterResp.IUserRegisterResp = UserRegisterResp.UserRegisterRespCodec.decode(input);
                        _args.success = value_81;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class RegisterUser__Result extends thrift.StructLike implements IRegisterUser__Result {
    public success?: UserRegisterResp.IUserRegisterResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IRegisterUser__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_82: UserRegisterResp.IUserRegisterResp = new UserRegisterResp.UserRegisterResp(args.success);
            this.success = value_82;
        }
    }
    public static read(input: thrift.TProtocol): RegisterUser__Result {
        return new RegisterUser__Result(RegisterUser__ResultCodec.decode(input));
    }
    public static write(args: IRegisterUser__ResultArgs, output: thrift.TProtocol): void {
        return RegisterUser__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return RegisterUser__ResultCodec.encode(this, output);
    }
}
export interface ILoginUser__Result {
    success?: UserLoginResp.IUserLoginResp;
}
export interface ILoginUser__ResultArgs {
    success?: UserLoginResp.IUserLoginRespArgs;
}
export const LoginUser__ResultCodec: thrift.IStructCodec<ILoginUser__ResultArgs, ILoginUser__Result> = {
    encode(args: ILoginUser__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("LoginUser__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            UserLoginResp.UserLoginRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ILoginUser__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_83: UserLoginResp.IUserLoginResp = UserLoginResp.UserLoginRespCodec.decode(input);
                        _args.success = value_83;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class LoginUser__Result extends thrift.StructLike implements ILoginUser__Result {
    public success?: UserLoginResp.IUserLoginResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ILoginUser__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_84: UserLoginResp.IUserLoginResp = new UserLoginResp.UserLoginResp(args.success);
            this.success = value_84;
        }
    }
    public static read(input: thrift.TProtocol): LoginUser__Result {
        return new LoginUser__Result(LoginUser__ResultCodec.decode(input));
    }
    public static write(args: ILoginUser__ResultArgs, output: thrift.TProtocol): void {
        return LoginUser__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return LoginUser__ResultCodec.encode(this, output);
    }
}
export interface IGetUserInfo__Result {
    success?: UserInfoResp.IUserInfoResp;
}
export interface IGetUserInfo__ResultArgs {
    success?: UserInfoResp.IUserInfoRespArgs;
}
export const GetUserInfo__ResultCodec: thrift.IStructCodec<IGetUserInfo__ResultArgs, IGetUserInfo__Result> = {
    encode(args: IGetUserInfo__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetUserInfo__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            UserInfoResp.UserInfoRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetUserInfo__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_85: UserInfoResp.IUserInfoResp = UserInfoResp.UserInfoRespCodec.decode(input);
                        _args.success = value_85;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetUserInfo__Result extends thrift.StructLike implements IGetUserInfo__Result {
    public success?: UserInfoResp.IUserInfoResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetUserInfo__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_86: UserInfoResp.IUserInfoResp = new UserInfoResp.UserInfoResp(args.success);
            this.success = value_86;
        }
    }
    public static read(input: thrift.TProtocol): GetUserInfo__Result {
        return new GetUserInfo__Result(GetUserInfo__ResultCodec.decode(input));
    }
    public static write(args: IGetUserInfo__ResultArgs, output: thrift.TProtocol): void {
        return GetUserInfo__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetUserInfo__ResultCodec.encode(this, output);
    }
}
export interface IUpdateUser__Result {
    success?: UserUpdateResp.IUserUpdateResp;
}
export interface IUpdateUser__ResultArgs {
    success?: UserUpdateResp.IUserUpdateRespArgs;
}
export const UpdateUser__ResultCodec: thrift.IStructCodec<IUpdateUser__ResultArgs, IUpdateUser__Result> = {
    encode(args: IUpdateUser__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("UpdateUser__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            UserUpdateResp.UserUpdateRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateUser__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_87: UserUpdateResp.IUserUpdateResp = UserUpdateResp.UserUpdateRespCodec.decode(input);
                        _args.success = value_87;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class UpdateUser__Result extends thrift.StructLike implements IUpdateUser__Result {
    public success?: UserUpdateResp.IUserUpdateResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateUser__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_88: UserUpdateResp.IUserUpdateResp = new UserUpdateResp.UserUpdateResp(args.success);
            this.success = value_88;
        }
    }
    public static read(input: thrift.TProtocol): UpdateUser__Result {
        return new UpdateUser__Result(UpdateUser__ResultCodec.decode(input));
    }
    public static write(args: IUpdateUser__ResultArgs, output: thrift.TProtocol): void {
        return UpdateUser__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateUser__ResultCodec.encode(this, output);
    }
}
export class Client<Context = any> extends thrift.ThriftClient<Context> {
    public static readonly serviceName: string = serviceName;
    public static readonly annotations: thrift.IThriftAnnotations = annotations;
    public static readonly methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public static readonly methodNames: Array<string> = methodNames;
    public readonly _serviceName: string = serviceName;
    public readonly _annotations: thrift.IThriftAnnotations = annotations;
    public readonly _methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public readonly _methodNames: Array<string> = methodNames;
    public readonly _methodParameters?: {
        [methodName: string]: number;
    } = methodParameters;
    public Ping(req: PingReq.IPingReqArgs, context?: Context): Promise<PingResp.IPingResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("Ping", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IPing__ArgsArgs = { req };
        Ping__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "Ping") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IPing__Result = Ping__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "Ping failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public QueueMaterial(req: QueueMaterialReq.IQueueMaterialReqArgs, context?: Context): Promise<QueueMaterialResp.IQueueMaterialResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("QueueMaterial", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IQueueMaterial__ArgsArgs = { req };
        QueueMaterial__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "QueueMaterial") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IQueueMaterial__Result = QueueMaterial__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "QueueMaterial failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetTosStsToken(req: EmptyRequest.IEmptyRequestArgs, context?: Context): Promise<TosStsTokenResp.ITosStsTokenResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetTosStsToken", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IGetTosStsToken__ArgsArgs = { req };
        GetTosStsToken__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetTosStsToken") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetTosStsToken__Result = GetTosStsToken__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetTosStsToken failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetFolderList(req: FolderListReq.IFolderListReqArgs, context?: Context): Promise<FolderListResp.IFolderListResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetFolderList", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IGetFolderList__ArgsArgs = { req };
        GetFolderList__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetFolderList") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetFolderList__Result = GetFolderList__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetFolderList failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetFolderDetail(req: FolderDetailReq.IFolderDetailReqArgs, context?: Context): Promise<FolderDetailResp.IFolderDetailResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetFolderDetail", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IGetFolderDetail__ArgsArgs = { req };
        GetFolderDetail__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetFolderDetail") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetFolderDetail__Result = GetFolderDetail__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetFolderDetail failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public CreateFolder(req: FolderCreateReq.IFolderCreateReqArgs, context?: Context): Promise<FolderCreateResp.IFolderCreateResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("CreateFolder", thrift.MessageType.CALL, this.incrementRequestId());
        const args: ICreateFolder__ArgsArgs = { req };
        CreateFolder__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "CreateFolder") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: ICreateFolder__Result = CreateFolder__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "CreateFolder failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public UpdateFolder(req: FolderUpdateReq.IFolderUpdateReqArgs, context?: Context): Promise<FolderUpdateResp.IFolderUpdateResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("UpdateFolder", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IUpdateFolder__ArgsArgs = { req };
        UpdateFolder__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "UpdateFolder") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IUpdateFolder__Result = UpdateFolder__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "UpdateFolder failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public DeleteFolder(req: FolderDeleteReq.IFolderDeleteReqArgs, context?: Context): Promise<FolderDeleteResp.IFolderDeleteResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("DeleteFolder", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IDeleteFolder__ArgsArgs = { req };
        DeleteFolder__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "DeleteFolder") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IDeleteFolder__Result = DeleteFolder__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "DeleteFolder failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetMaterialList(req: MaterialListReq.IMaterialListReqArgs, context?: Context): Promise<MaterialListResp.IMaterialListResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetMaterialList", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IGetMaterialList__ArgsArgs = { req };
        GetMaterialList__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetMaterialList") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetMaterialList__Result = GetMaterialList__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetMaterialList failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetMaterialDetail(req: MaterialDetailReq.IMaterialDetailReqArgs, context?: Context): Promise<MaterialDetailResp.IMaterialDetailResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetMaterialDetail", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IGetMaterialDetail__ArgsArgs = { req };
        GetMaterialDetail__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetMaterialDetail") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetMaterialDetail__Result = GetMaterialDetail__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetMaterialDetail failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public CreateMaterial(req: MaterialCreateReq.IMaterialCreateReqArgs, context?: Context): Promise<MaterialCreateResp.IMaterialCreateResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("CreateMaterial", thrift.MessageType.CALL, this.incrementRequestId());
        const args: ICreateMaterial__ArgsArgs = { req };
        CreateMaterial__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "CreateMaterial") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: ICreateMaterial__Result = CreateMaterial__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "CreateMaterial failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public UpdateMaterial(req: MaterialUpdateReq.IMaterialUpdateReqArgs, context?: Context): Promise<MaterialUpdateResp.IMaterialUpdateResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("UpdateMaterial", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IUpdateMaterial__ArgsArgs = { req };
        UpdateMaterial__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "UpdateMaterial") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IUpdateMaterial__Result = UpdateMaterial__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "UpdateMaterial failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public DeleteMaterial(req: MaterialDeleteReq.IMaterialDeleteReqArgs, context?: Context): Promise<MaterialDeleteResp.IMaterialDeleteResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("DeleteMaterial", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IDeleteMaterial__ArgsArgs = { req };
        DeleteMaterial__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "DeleteMaterial") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IDeleteMaterial__Result = DeleteMaterial__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "DeleteMaterial failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetProductList(req: ProductListReq.IProductListReqArgs, context?: Context): Promise<ProductListResp.IProductListResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetProductList", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IGetProductList__ArgsArgs = { req };
        GetProductList__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetProductList") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetProductList__Result = GetProductList__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetProductList failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetProductDetail(req: ProductDetailReq.IProductDetailReqArgs, context?: Context): Promise<ProductDetailResp.IProductDetailResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetProductDetail", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IGetProductDetail__ArgsArgs = { req };
        GetProductDetail__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetProductDetail") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetProductDetail__Result = GetProductDetail__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetProductDetail failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public CreateProduct(req: ProductCreateReq.IProductCreateReqArgs, context?: Context): Promise<ProductCreateResp.IProductCreateResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("CreateProduct", thrift.MessageType.CALL, this.incrementRequestId());
        const args: ICreateProduct__ArgsArgs = { req };
        CreateProduct__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "CreateProduct") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: ICreateProduct__Result = CreateProduct__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "CreateProduct failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public UpdateProduct(req: ProductUpdateReq.IProductUpdateReqArgs, context?: Context): Promise<ProductUpdateResp.IProductUpdateResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("UpdateProduct", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IUpdateProduct__ArgsArgs = { req };
        UpdateProduct__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "UpdateProduct") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IUpdateProduct__Result = UpdateProduct__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "UpdateProduct failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public DeleteProduct(req: ProductDeleteReq.IProductDeleteReqArgs, context?: Context): Promise<ProductDeleteResp.IProductDeleteResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("DeleteProduct", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IDeleteProduct__ArgsArgs = { req };
        DeleteProduct__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "DeleteProduct") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IDeleteProduct__Result = DeleteProduct__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "DeleteProduct failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public RegisterUser(req: UserRegisterReq.IUserRegisterReqArgs, context?: Context): Promise<UserRegisterResp.IUserRegisterResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("RegisterUser", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IRegisterUser__ArgsArgs = { req };
        RegisterUser__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "RegisterUser") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IRegisterUser__Result = RegisterUser__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "RegisterUser failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public LoginUser(req: UserLoginReq.IUserLoginReqArgs, context?: Context): Promise<UserLoginResp.IUserLoginResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("LoginUser", thrift.MessageType.CALL, this.incrementRequestId());
        const args: ILoginUser__ArgsArgs = { req };
        LoginUser__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "LoginUser") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: ILoginUser__Result = LoginUser__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "LoginUser failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetUserInfo(req: EmptyRequest.IEmptyRequestArgs, context?: Context): Promise<UserInfoResp.IUserInfoResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetUserInfo", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IGetUserInfo__ArgsArgs = { req };
        GetUserInfo__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetUserInfo") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetUserInfo__Result = GetUserInfo__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetUserInfo failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public UpdateUser(req: UserUpdateReq.IUserUpdateReqArgs, context?: Context): Promise<UserUpdateResp.IUserUpdateResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("UpdateUser", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IUpdateUser__ArgsArgs = { req };
        UpdateUser__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "UpdateUser") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IUpdateUser__Result = UpdateUser__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "UpdateUser failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
}
export interface IHandler<Context = any> {
    Ping(req: PingReq.IPingReq, context?: Context): PingResp.IPingRespArgs | Promise<PingResp.IPingRespArgs>;
    QueueMaterial(req: QueueMaterialReq.IQueueMaterialReq, context?: Context): QueueMaterialResp.IQueueMaterialRespArgs | Promise<QueueMaterialResp.IQueueMaterialRespArgs>;
    GetTosStsToken(req: EmptyRequest.IEmptyRequest, context?: Context): TosStsTokenResp.ITosStsTokenRespArgs | Promise<TosStsTokenResp.ITosStsTokenRespArgs>;
    GetFolderList(req: FolderListReq.IFolderListReq, context?: Context): FolderListResp.IFolderListRespArgs | Promise<FolderListResp.IFolderListRespArgs>;
    GetFolderDetail(req: FolderDetailReq.IFolderDetailReq, context?: Context): FolderDetailResp.IFolderDetailRespArgs | Promise<FolderDetailResp.IFolderDetailRespArgs>;
    CreateFolder(req: FolderCreateReq.IFolderCreateReq, context?: Context): FolderCreateResp.IFolderCreateRespArgs | Promise<FolderCreateResp.IFolderCreateRespArgs>;
    UpdateFolder(req: FolderUpdateReq.IFolderUpdateReq, context?: Context): FolderUpdateResp.IFolderUpdateRespArgs | Promise<FolderUpdateResp.IFolderUpdateRespArgs>;
    DeleteFolder(req: FolderDeleteReq.IFolderDeleteReq, context?: Context): FolderDeleteResp.IFolderDeleteRespArgs | Promise<FolderDeleteResp.IFolderDeleteRespArgs>;
    GetMaterialList(req: MaterialListReq.IMaterialListReq, context?: Context): MaterialListResp.IMaterialListRespArgs | Promise<MaterialListResp.IMaterialListRespArgs>;
    GetMaterialDetail(req: MaterialDetailReq.IMaterialDetailReq, context?: Context): MaterialDetailResp.IMaterialDetailRespArgs | Promise<MaterialDetailResp.IMaterialDetailRespArgs>;
    CreateMaterial(req: MaterialCreateReq.IMaterialCreateReq, context?: Context): MaterialCreateResp.IMaterialCreateRespArgs | Promise<MaterialCreateResp.IMaterialCreateRespArgs>;
    UpdateMaterial(req: MaterialUpdateReq.IMaterialUpdateReq, context?: Context): MaterialUpdateResp.IMaterialUpdateRespArgs | Promise<MaterialUpdateResp.IMaterialUpdateRespArgs>;
    DeleteMaterial(req: MaterialDeleteReq.IMaterialDeleteReq, context?: Context): MaterialDeleteResp.IMaterialDeleteRespArgs | Promise<MaterialDeleteResp.IMaterialDeleteRespArgs>;
    GetProductList(req: ProductListReq.IProductListReq, context?: Context): ProductListResp.IProductListRespArgs | Promise<ProductListResp.IProductListRespArgs>;
    GetProductDetail(req: ProductDetailReq.IProductDetailReq, context?: Context): ProductDetailResp.IProductDetailRespArgs | Promise<ProductDetailResp.IProductDetailRespArgs>;
    CreateProduct(req: ProductCreateReq.IProductCreateReq, context?: Context): ProductCreateResp.IProductCreateRespArgs | Promise<ProductCreateResp.IProductCreateRespArgs>;
    UpdateProduct(req: ProductUpdateReq.IProductUpdateReq, context?: Context): ProductUpdateResp.IProductUpdateRespArgs | Promise<ProductUpdateResp.IProductUpdateRespArgs>;
    DeleteProduct(req: ProductDeleteReq.IProductDeleteReq, context?: Context): ProductDeleteResp.IProductDeleteRespArgs | Promise<ProductDeleteResp.IProductDeleteRespArgs>;
    RegisterUser(req: UserRegisterReq.IUserRegisterReq, context?: Context): UserRegisterResp.IUserRegisterRespArgs | Promise<UserRegisterResp.IUserRegisterRespArgs>;
    LoginUser(req: UserLoginReq.IUserLoginReq, context?: Context): UserLoginResp.IUserLoginRespArgs | Promise<UserLoginResp.IUserLoginRespArgs>;
    GetUserInfo(req: EmptyRequest.IEmptyRequest, context?: Context): UserInfoResp.IUserInfoRespArgs | Promise<UserInfoResp.IUserInfoRespArgs>;
    UpdateUser(req: UserUpdateReq.IUserUpdateReq, context?: Context): UserUpdateResp.IUserUpdateRespArgs | Promise<UserUpdateResp.IUserUpdateRespArgs>;
}
export class Processor<Context = any> extends thrift.ThriftProcessor<Context, IHandler<Context>> {
    protected readonly _handler: IHandler<Context>;
    public static readonly serviceName: string = serviceName;
    public static readonly annotations: thrift.IThriftAnnotations = annotations;
    public static readonly methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public static readonly methodNames: Array<string> = methodNames;
    public readonly _serviceName: string = serviceName;
    public readonly _annotations: thrift.IThriftAnnotations = annotations;
    public readonly _methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public readonly _methodNames: Array<string> = methodNames;
    constructor(handler: IHandler<Context>) {
        super();
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<Buffer>((resolve, reject): void => {
            const metadata: thrift.IThriftMessage = input.readMessageBegin();
            const fieldName: string = metadata.fieldName;
            const requestId: number = metadata.requestId;
            const methodName: string = "process_" + fieldName;
            switch (methodName) {
                case "process_Ping": {
                    resolve(this.process_Ping(requestId, input, output, context));
                    break;
                }
                case "process_QueueMaterial": {
                    resolve(this.process_QueueMaterial(requestId, input, output, context));
                    break;
                }
                case "process_GetTosStsToken": {
                    resolve(this.process_GetTosStsToken(requestId, input, output, context));
                    break;
                }
                case "process_GetFolderList": {
                    resolve(this.process_GetFolderList(requestId, input, output, context));
                    break;
                }
                case "process_GetFolderDetail": {
                    resolve(this.process_GetFolderDetail(requestId, input, output, context));
                    break;
                }
                case "process_CreateFolder": {
                    resolve(this.process_CreateFolder(requestId, input, output, context));
                    break;
                }
                case "process_UpdateFolder": {
                    resolve(this.process_UpdateFolder(requestId, input, output, context));
                    break;
                }
                case "process_DeleteFolder": {
                    resolve(this.process_DeleteFolder(requestId, input, output, context));
                    break;
                }
                case "process_GetMaterialList": {
                    resolve(this.process_GetMaterialList(requestId, input, output, context));
                    break;
                }
                case "process_GetMaterialDetail": {
                    resolve(this.process_GetMaterialDetail(requestId, input, output, context));
                    break;
                }
                case "process_CreateMaterial": {
                    resolve(this.process_CreateMaterial(requestId, input, output, context));
                    break;
                }
                case "process_UpdateMaterial": {
                    resolve(this.process_UpdateMaterial(requestId, input, output, context));
                    break;
                }
                case "process_DeleteMaterial": {
                    resolve(this.process_DeleteMaterial(requestId, input, output, context));
                    break;
                }
                case "process_GetProductList": {
                    resolve(this.process_GetProductList(requestId, input, output, context));
                    break;
                }
                case "process_GetProductDetail": {
                    resolve(this.process_GetProductDetail(requestId, input, output, context));
                    break;
                }
                case "process_CreateProduct": {
                    resolve(this.process_CreateProduct(requestId, input, output, context));
                    break;
                }
                case "process_UpdateProduct": {
                    resolve(this.process_UpdateProduct(requestId, input, output, context));
                    break;
                }
                case "process_DeleteProduct": {
                    resolve(this.process_DeleteProduct(requestId, input, output, context));
                    break;
                }
                case "process_RegisterUser": {
                    resolve(this.process_RegisterUser(requestId, input, output, context));
                    break;
                }
                case "process_LoginUser": {
                    resolve(this.process_LoginUser(requestId, input, output, context));
                    break;
                }
                case "process_GetUserInfo": {
                    resolve(this.process_GetUserInfo(requestId, input, output, context));
                    break;
                }
                case "process_UpdateUser": {
                    resolve(this.process_UpdateUser(requestId, input, output, context));
                    break;
                }
                default: {
                    input.skip(thrift.TType.STRUCT);
                    input.readMessageEnd();
                    const errMessage = "Unknown function " + fieldName;
                    const err = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                    output.writeMessageBegin(fieldName, thrift.MessageType.EXCEPTION, requestId);
                    thrift.TApplicationExceptionCodec.encode(err, output);
                    output.writeMessageEnd();
                    resolve(output.flush());
                    break;
                }
            }
        });
    }
    public process_Ping(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<PingResp.IPingRespArgs>((resolve, reject): void => {
            try {
                const args: IPing__Args = Ping__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.Ping(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: PingResp.IPingRespArgs): Buffer => {
            const result: IPing__ResultArgs = { success: data };
            output.writeMessageBegin("Ping", thrift.MessageType.REPLY, requestId);
            Ping__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("Ping", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_QueueMaterial(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<QueueMaterialResp.IQueueMaterialRespArgs>((resolve, reject): void => {
            try {
                const args: IQueueMaterial__Args = QueueMaterial__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.QueueMaterial(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: QueueMaterialResp.IQueueMaterialRespArgs): Buffer => {
            const result: IQueueMaterial__ResultArgs = { success: data };
            output.writeMessageBegin("QueueMaterial", thrift.MessageType.REPLY, requestId);
            QueueMaterial__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("QueueMaterial", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetTosStsToken(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<TosStsTokenResp.ITosStsTokenRespArgs>((resolve, reject): void => {
            try {
                const args: IGetTosStsToken__Args = GetTosStsToken__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetTosStsToken(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TosStsTokenResp.ITosStsTokenRespArgs): Buffer => {
            const result: IGetTosStsToken__ResultArgs = { success: data };
            output.writeMessageBegin("GetTosStsToken", thrift.MessageType.REPLY, requestId);
            GetTosStsToken__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetTosStsToken", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetFolderList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<FolderListResp.IFolderListRespArgs>((resolve, reject): void => {
            try {
                const args: IGetFolderList__Args = GetFolderList__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetFolderList(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: FolderListResp.IFolderListRespArgs): Buffer => {
            const result: IGetFolderList__ResultArgs = { success: data };
            output.writeMessageBegin("GetFolderList", thrift.MessageType.REPLY, requestId);
            GetFolderList__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetFolderList", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetFolderDetail(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<FolderDetailResp.IFolderDetailRespArgs>((resolve, reject): void => {
            try {
                const args: IGetFolderDetail__Args = GetFolderDetail__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetFolderDetail(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: FolderDetailResp.IFolderDetailRespArgs): Buffer => {
            const result: IGetFolderDetail__ResultArgs = { success: data };
            output.writeMessageBegin("GetFolderDetail", thrift.MessageType.REPLY, requestId);
            GetFolderDetail__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetFolderDetail", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_CreateFolder(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<FolderCreateResp.IFolderCreateRespArgs>((resolve, reject): void => {
            try {
                const args: ICreateFolder__Args = CreateFolder__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.CreateFolder(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: FolderCreateResp.IFolderCreateRespArgs): Buffer => {
            const result: ICreateFolder__ResultArgs = { success: data };
            output.writeMessageBegin("CreateFolder", thrift.MessageType.REPLY, requestId);
            CreateFolder__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("CreateFolder", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_UpdateFolder(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<FolderUpdateResp.IFolderUpdateRespArgs>((resolve, reject): void => {
            try {
                const args: IUpdateFolder__Args = UpdateFolder__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.UpdateFolder(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: FolderUpdateResp.IFolderUpdateRespArgs): Buffer => {
            const result: IUpdateFolder__ResultArgs = { success: data };
            output.writeMessageBegin("UpdateFolder", thrift.MessageType.REPLY, requestId);
            UpdateFolder__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("UpdateFolder", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_DeleteFolder(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<FolderDeleteResp.IFolderDeleteRespArgs>((resolve, reject): void => {
            try {
                const args: IDeleteFolder__Args = DeleteFolder__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.DeleteFolder(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: FolderDeleteResp.IFolderDeleteRespArgs): Buffer => {
            const result: IDeleteFolder__ResultArgs = { success: data };
            output.writeMessageBegin("DeleteFolder", thrift.MessageType.REPLY, requestId);
            DeleteFolder__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("DeleteFolder", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetMaterialList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<MaterialListResp.IMaterialListRespArgs>((resolve, reject): void => {
            try {
                const args: IGetMaterialList__Args = GetMaterialList__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetMaterialList(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: MaterialListResp.IMaterialListRespArgs): Buffer => {
            const result: IGetMaterialList__ResultArgs = { success: data };
            output.writeMessageBegin("GetMaterialList", thrift.MessageType.REPLY, requestId);
            GetMaterialList__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetMaterialList", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetMaterialDetail(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<MaterialDetailResp.IMaterialDetailRespArgs>((resolve, reject): void => {
            try {
                const args: IGetMaterialDetail__Args = GetMaterialDetail__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetMaterialDetail(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: MaterialDetailResp.IMaterialDetailRespArgs): Buffer => {
            const result: IGetMaterialDetail__ResultArgs = { success: data };
            output.writeMessageBegin("GetMaterialDetail", thrift.MessageType.REPLY, requestId);
            GetMaterialDetail__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetMaterialDetail", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_CreateMaterial(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<MaterialCreateResp.IMaterialCreateRespArgs>((resolve, reject): void => {
            try {
                const args: ICreateMaterial__Args = CreateMaterial__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.CreateMaterial(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: MaterialCreateResp.IMaterialCreateRespArgs): Buffer => {
            const result: ICreateMaterial__ResultArgs = { success: data };
            output.writeMessageBegin("CreateMaterial", thrift.MessageType.REPLY, requestId);
            CreateMaterial__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("CreateMaterial", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_UpdateMaterial(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<MaterialUpdateResp.IMaterialUpdateRespArgs>((resolve, reject): void => {
            try {
                const args: IUpdateMaterial__Args = UpdateMaterial__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.UpdateMaterial(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: MaterialUpdateResp.IMaterialUpdateRespArgs): Buffer => {
            const result: IUpdateMaterial__ResultArgs = { success: data };
            output.writeMessageBegin("UpdateMaterial", thrift.MessageType.REPLY, requestId);
            UpdateMaterial__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("UpdateMaterial", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_DeleteMaterial(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<MaterialDeleteResp.IMaterialDeleteRespArgs>((resolve, reject): void => {
            try {
                const args: IDeleteMaterial__Args = DeleteMaterial__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.DeleteMaterial(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: MaterialDeleteResp.IMaterialDeleteRespArgs): Buffer => {
            const result: IDeleteMaterial__ResultArgs = { success: data };
            output.writeMessageBegin("DeleteMaterial", thrift.MessageType.REPLY, requestId);
            DeleteMaterial__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("DeleteMaterial", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetProductList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<ProductListResp.IProductListRespArgs>((resolve, reject): void => {
            try {
                const args: IGetProductList__Args = GetProductList__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetProductList(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ProductListResp.IProductListRespArgs): Buffer => {
            const result: IGetProductList__ResultArgs = { success: data };
            output.writeMessageBegin("GetProductList", thrift.MessageType.REPLY, requestId);
            GetProductList__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetProductList", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetProductDetail(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<ProductDetailResp.IProductDetailRespArgs>((resolve, reject): void => {
            try {
                const args: IGetProductDetail__Args = GetProductDetail__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetProductDetail(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ProductDetailResp.IProductDetailRespArgs): Buffer => {
            const result: IGetProductDetail__ResultArgs = { success: data };
            output.writeMessageBegin("GetProductDetail", thrift.MessageType.REPLY, requestId);
            GetProductDetail__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetProductDetail", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_CreateProduct(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<ProductCreateResp.IProductCreateRespArgs>((resolve, reject): void => {
            try {
                const args: ICreateProduct__Args = CreateProduct__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.CreateProduct(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ProductCreateResp.IProductCreateRespArgs): Buffer => {
            const result: ICreateProduct__ResultArgs = { success: data };
            output.writeMessageBegin("CreateProduct", thrift.MessageType.REPLY, requestId);
            CreateProduct__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("CreateProduct", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_UpdateProduct(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<ProductUpdateResp.IProductUpdateRespArgs>((resolve, reject): void => {
            try {
                const args: IUpdateProduct__Args = UpdateProduct__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.UpdateProduct(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ProductUpdateResp.IProductUpdateRespArgs): Buffer => {
            const result: IUpdateProduct__ResultArgs = { success: data };
            output.writeMessageBegin("UpdateProduct", thrift.MessageType.REPLY, requestId);
            UpdateProduct__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("UpdateProduct", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_DeleteProduct(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<ProductDeleteResp.IProductDeleteRespArgs>((resolve, reject): void => {
            try {
                const args: IDeleteProduct__Args = DeleteProduct__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.DeleteProduct(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ProductDeleteResp.IProductDeleteRespArgs): Buffer => {
            const result: IDeleteProduct__ResultArgs = { success: data };
            output.writeMessageBegin("DeleteProduct", thrift.MessageType.REPLY, requestId);
            DeleteProduct__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("DeleteProduct", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_RegisterUser(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<UserRegisterResp.IUserRegisterRespArgs>((resolve, reject): void => {
            try {
                const args: IRegisterUser__Args = RegisterUser__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.RegisterUser(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: UserRegisterResp.IUserRegisterRespArgs): Buffer => {
            const result: IRegisterUser__ResultArgs = { success: data };
            output.writeMessageBegin("RegisterUser", thrift.MessageType.REPLY, requestId);
            RegisterUser__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("RegisterUser", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_LoginUser(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<UserLoginResp.IUserLoginRespArgs>((resolve, reject): void => {
            try {
                const args: ILoginUser__Args = LoginUser__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.LoginUser(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: UserLoginResp.IUserLoginRespArgs): Buffer => {
            const result: ILoginUser__ResultArgs = { success: data };
            output.writeMessageBegin("LoginUser", thrift.MessageType.REPLY, requestId);
            LoginUser__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("LoginUser", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetUserInfo(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<UserInfoResp.IUserInfoRespArgs>((resolve, reject): void => {
            try {
                const args: IGetUserInfo__Args = GetUserInfo__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetUserInfo(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: UserInfoResp.IUserInfoRespArgs): Buffer => {
            const result: IGetUserInfo__ResultArgs = { success: data };
            output.writeMessageBegin("GetUserInfo", thrift.MessageType.REPLY, requestId);
            GetUserInfo__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetUserInfo", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_UpdateUser(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<UserUpdateResp.IUserUpdateRespArgs>((resolve, reject): void => {
            try {
                const args: IUpdateUser__Args = UpdateUser__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.UpdateUser(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: UserUpdateResp.IUserUpdateRespArgs): Buffer => {
            const result: IUpdateUser__ResultArgs = { success: data };
            output.writeMessageBegin("UpdateUser", thrift.MessageType.REPLY, requestId);
            UpdateUser__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("UpdateUser", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
}
